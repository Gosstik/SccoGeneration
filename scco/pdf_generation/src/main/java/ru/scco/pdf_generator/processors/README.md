Постобработка осуществляется с использованием chain of responsibility:


<h4>ProcessNode:</h4>
Каждый тип обработки реализуется через класс имплементирующий ProcessNode
ProcessNode содержит единственный метод process, принимающий текст, который 
необходимо обработать. Метод может вызывать InvalidCPException, если в ходе 
обработки было установлено, что генерация по оставшемуся тексту бессмысленна.


<h4>ProcessingChain:</h4>
ProcessingChain - точка входа в цепочку обработки.
ProcessingChain хранит в себе список наследников ProcessNode, при этом также 
имплементирует ProcessNode. На данный момент обработчики в списке 
фиксируются в конструкторе ProcessingChain: сначала идет удаление имени, 
потом удаление в конце (последних 30% текста) предложений, содержащих "С 
уважением", потом удаление предложений, содержащих []

Пока что, не требуется динамически добавлять новые обработчики, но если 
потребуется, ProcessChain содержит метод append


<h4>SentenceProcessNode и SentenceProcessingChain</h4>
Эти классы в текущей реализации приложения оказались не нужны, однако 
в дальнейшем могут понадобиться. Они созданы для обработчиков, которые 
работают не со всем текстом, а со списком предложений. (Например, можно 
было бы "С уважением" искать не в последних 30% текста, а в 2-3 
последних предложениях. И если таких обработчиков несколько, то есть 
смысл делить 
текст на предложения не в каждом обработчике, а только в начале цепочки таких 
обработчиков).

SentenceProcessNode, аналогичен ProcessNode, но принимает список строк, а 
не сплошной текст.

SentenceProcessingChain - точка входа в цепочку из SentenceProcessNode. 
Аналогично ProcessingChain хранит список обработчиков и имплементирует 
ProcessNode. Однако обработчики должны быть наследниками SentenceProcessNode,
а при вызове process текст делится на предложения, после чего передается 
обработчикам. Деления производится по знакам пунктуации, при этом знаки 
остаются в предложении. После прохождения цепочки, предложения склеиваются
